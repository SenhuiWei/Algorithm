Memset函数的使用
头文件：    
C:<memory.h>/<string.h>     
C++:< cstring >  
话说刚开始使用memset的时候一直以为memset是对每一个int赋值的，心里想有了memset还要for循环对数组进行初始化干嘛。
但其实memset这个函数的作用是将数字以单个字节逐个拷贝的方式放到指定的内存中去

>memset(dp,0,sizeof(dp));  

int类型的变量一般占用4个字节，对每一个字节赋值0的话就变成了“00000000 00000000 000000000 00000000” （即10进制数中的0）

>memset(dp,-1,sizeof(dp));  

赋值为-1的话，放的是 “11111111 11111111 11111111 11111111 ”（十进制的-1）
这样你可能以为如果你赋值1的话会让整个dp数组里的每一个int变成1，其实不然。

>memset(dp,1,sizeof(dp));   

以上代码执行后，dp数组的内容为 00000001 00000001 00000001 00000001 转化为十进制后不为1

我们在很多程序中都会看到这样的代码，

>memset(a,127,sizeof(a));

127是什么特别的数字呢？通过基础的进制转换可以得知127的二进制表示是01111111，那么在dp数组里放的内容就是“01111111 01111111 01111111 01111111”，（10进制的2139062143），这样就实现了将数组里的全部元素初始化为一个很大的数的目的了，在最短路径问题以及其他很多算法中都是需要用到的。值得注意的是，int类型的范围为2^31-1，大约是2147483647的样子（如果我没有记错的话），所以初始化int类型的数组也可以使用127这个数值。


>memset(a,128,sizeof(a));

如果是128呢？因为128的二进制是10000000，那么放的内容就是10000000 10000000 10000000 10000000，经过计算可得这个数是-2139062144。这样就可以将数组初始化为一个很小的数了

>memset(a, 0x3f, sizeof(a));

0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。
另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。
最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。
所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择。

总结起来就是三句话
1 够大，一般这么大你不会用到
2 够大但不容易溢出
3 方便数组赋值（如果你用FF会变成负数，符号位也会成1）
